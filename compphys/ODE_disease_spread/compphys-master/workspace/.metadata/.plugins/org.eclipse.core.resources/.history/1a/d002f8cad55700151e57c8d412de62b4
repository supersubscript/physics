public final class ODEsolver {

	private ODEsolver() {
	}

	// calculates the number of people in a group (S, I or R) that travels to
	// the node with index n
	private static double travelSum(double[][] commute, double[] numOfPeople, int n) {
		double sum = 0;
		for (int m = 0; m < numOfPeople.length; m++)
			sum += commute[m][n] * numOfPeople[m] - commute[n][m] * numOfPeople[n];
		return sum;
	}

	/*
	 * Takes in a network and a disease, utilizing these to
	 * compute a timeStep through solving the to the model inherent ODE.
	 */
	public static Network timeStep(Network network, Disease disease, double h) {
		double alpha = disease.getAlpha();
		double beta = disease.getBeta();
		double gamma = disease.getGamma();
		Node[] nodes = network.getNodes(); // nodes with initial values
		double[][] commute = network.getCommute();
		int nlen = nodes.length; // used a lot
		
		double[][] kS = new double[4][nlen], kI = new double[4][nlen], kR = new double[4][nlen];
		double[] tempS = new double[nlen], tempI = new double[nlen], tempR = new double[nlen],
				tempN = new double[nlen];

		double[] svals = new double[nlen], ivals = new double[nlen], rvals= new double[nlen]; 

		// Saves away values for later use
		for(int i = 0; i < nlen; i++)
		{
			svals[i] = nodes[i].getS();
			ivals[i] = nodes[i].getI();
			rvals[i] = nodes[i].getR();
			tempN[i] = svals[i] + ivals[i] + rvals[i];
		}
		tempS  = svals ;
		tempI  = ivals ;
		tempR  = rvals ;
		// calculates k<>[0][n] (k1 in Runge-Kutta) for all n (nodes), where <>
		// is S, I or R
		for (int i = 0; i < nlen; i++) {
			kS[0][i] = h * (-tempS[i] * (beta * tempI[i] + gamma * tempN[i]) / tempN[i] + travelSum(commute, tempS, i));
			kI[0][i] = h * (tempI[i] * (beta * tempS[i] - alpha * tempN[i]) / tempN[i] + travelSum(commute, tempI, i));
			kR[0][i] = h * (gamma * tempS[i] + alpha * tempI[i] + travelSum(commute, tempR, i));
		}

		// calculates the new values of the temp arrays (for calculation of k2)
		for (int i = 0; i < nlen; i++) {
			tempS[i] = svals[i] + .5 * kS[0][i];
			tempI[i] = ivals[i] + .5 * kI[0][i];
			tempR[i] = rvals[i] + .5 * kR[0][i];
			tempN[i] = tempS[i] + tempI[i] + tempR[i];
		}

		// calculates k<>[1][n] (k2 in Runge-Kutta) for all n (nodes), where <>
		// is S, I or R
		for (int i = 0; i < nlen; i++) {
			kS[1][i] = h * (-tempS[i] * (beta * tempI[i] + gamma * tempN[i]) / tempN[i] + travelSum(commute, tempS, i));
			kI[1][i] = h * (tempI[i] * (beta * tempS[i] - alpha * tempN[i]) / tempN[i] + travelSum(commute, tempI, i));
			kR[1][i] = h * (gamma * tempS[i] + alpha * tempI[i] + travelSum(commute, tempR, i));
		}

		// calculates the new values of the temp arrays (for calculation of k3)
		for (int i = 0; i < nlen; i++) {
			tempS[i] = svals[i] + .5 * kS[1][i];
			tempI[i] = ivals[i] + .5 * kI[1][i];
			tempR[i] = rvals[i] + .5 * kR[1][i];
			tempN[i] = tempS[i] + tempI[i] + tempR[i];
		}

		// calculates k<>[2][n] (k3 in Runge-Kutta) for all n (nodes), where <>
		// is S, I or R
		for (int i = 0; i < nlen; i++) {
			kS[2][i] = h * (-tempS[i] * (beta * tempI[i] + gamma * tempN[i]) / tempN[i] + travelSum(commute, tempS, i));
			kI[2][i] = h * (tempI[i] * (beta * tempS[i] - alpha * tempN[i]) / tempN[i] + travelSum(commute, tempI, i));
			kR[2][i] = h * (gamma * tempS[i] + alpha * tempI[i] + travelSum(commute, tempR, i));
		}

		// calculates the new values of the temp arrays (for calculation of k4)
		for (int i = 0; i < nlen; i++) {
			tempS[i] = svals[i] + kS[2][i];
			tempI[i] = ivals[i] + kI[2][i];
			tempR[i] = rvals[i] + kR[2][i];
			tempN[i] = tempS[i] + tempI[i] + tempR[i];
		}

		// calculates k<>[3][n] (k4 in Runge-Kutta) for all n (nodes), where <>
		// is S, I or R
		for (int i = 0; i < nlen; i++) {
			kS[3][i] = h * (-tempS[i] * (beta * tempI[i] + gamma * tempN[i]) / tempN[i] + travelSum(commute, tempS, i));
			kI[3][i] = h * (tempI[i] * (beta * tempS[i] - alpha * tempN[i]) / tempN[i] + travelSum(commute, tempI, i));
			kR[3][i] = h * (gamma * tempS[i] + alpha * tempI[i] + travelSum(commute, tempR, i));
		}

		// calculates the values for the next timestep
		for (int i = 0; i < nlen; i++) {
			nodes[i].setS(svals[i] + kS[0][i] / 6 + kS[1][i] / 3 + kS[2][i] / 3 + kS[3][i] / 6);
			nodes[i].setI(ivals[i] + kI[0][i] / 6 + kI[1][i] / 3 + kI[2][i] / 3 + kI[3][i] / 6);
			nodes[i].setR(rvals[i] + kR[0][i] / 6 + kR[1][i] / 3 + kR[2][i] / 3 + kR[3][i] / 6);
		}

		network.setNodes(nodes);

		return network;
	}

}
